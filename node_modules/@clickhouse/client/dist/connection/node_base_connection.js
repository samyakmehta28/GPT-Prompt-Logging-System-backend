"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NodeBaseConnection = void 0;
const client_common_1 = require("@clickhouse/client-common");
const crypto_1 = __importDefault(require("crypto"));
const stream_1 = __importDefault(require("stream"));
const zlib_1 = __importDefault(require("zlib"));
const utils_1 = require("../utils");
const compression_1 = require("./compression");
const stream_2 = require("./stream");
class NodeBaseConnection {
    constructor(params, agent) {
        Object.defineProperty(this, "params", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: params
        });
        Object.defineProperty(this, "agent", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: agent
        });
        Object.defineProperty(this, "headers", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "knownSockets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new WeakMap()
        });
        Object.defineProperty(this, "idleSocketTTL", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.logger = params.log_writer;
        this.idleSocketTTL = params.keep_alive.idle_socket_ttl;
        this.headers = this.buildDefaultHeaders(params.username, params.password, params.http_headers);
    }
    buildDefaultHeaders(username, password, additional_http_headers) {
        return {
            // KeepAlive agent for some reason does not set this on its own
            Connection: this.params.keep_alive.enabled ? 'keep-alive' : 'close',
            Authorization: `Basic ${Buffer.from(`${username}:${password}`).toString('base64')}`,
            'User-Agent': (0, utils_1.getUserAgent)(this.params.application_id),
            ...additional_http_headers,
        };
    }
    async request(params, op) {
        return new Promise((resolve, reject) => {
            const start = Date.now();
            const request = this.createClientRequest(params);
            function onError(err) {
                removeRequestListeners();
                reject(err);
            }
            const onResponse = async (_response) => {
                this.logResponse(op, request, params, _response, start);
                const decompressionResult = (0, compression_1.decompressResponse)(_response);
                if ((0, compression_1.isDecompressionError)(decompressionResult)) {
                    return reject(decompressionResult.error);
                }
                if ((0, client_common_1.isSuccessfulResponse)(_response.statusCode)) {
                    return resolve({
                        stream: decompressionResult.response,
                        summary: params.parse_summary
                            ? this.parseSummary(op, _response)
                            : undefined,
                    });
                }
                else {
                    reject((0, client_common_1.parseError)(await (0, utils_1.getAsText)(decompressionResult.response)));
                }
            };
            function onAbort() {
                // Prefer 'abort' event since it always triggered unlike 'error' and 'close'
                // see the full sequence of events https://nodejs.org/api/http.html#httprequesturl-options-callback
                removeRequestListeners();
                request.once('error', function () {
                    /**
                     * catch "Error: ECONNRESET" error which shouldn't be reported to users.
                     * see the full sequence of events https://nodejs.org/api/http.html#httprequesturl-options-callback
                     * */
                });
                reject(new Error('The user aborted a request.'));
            }
            function onClose() {
                // Adapter uses 'close' event to clean up listeners after the successful response.
                // It's necessary in order to handle 'abort' and 'timeout' events while response is streamed.
                // It's always the last event, according to https://nodejs.org/docs/latest-v14.x/api/http.html#http_http_request_url_options_callback
                removeRequestListeners();
            }
            function pipeStream() {
                // if request.end() was called due to no data to send
                if (request.writableEnded) {
                    return;
                }
                const bodyStream = (0, utils_1.isStream)(params.body)
                    ? params.body
                    : stream_1.default.Readable.from([params.body]);
                const callback = (err) => {
                    if (err) {
                        removeRequestListeners();
                        reject(err);
                    }
                };
                if (params.compress_request) {
                    stream_1.default.pipeline(bodyStream, zlib_1.default.createGzip(), request, callback);
                }
                else {
                    stream_1.default.pipeline(bodyStream, request, callback);
                }
            }
            const onSocket = (socket) => {
                if (this.params.keep_alive.enabled) {
                    const socketInfo = this.knownSockets.get(socket);
                    // It is the first time we encounter this socket,
                    // so it doesn't have the idle timeout handler attached to it
                    if (socketInfo === undefined) {
                        const socketId = crypto_1.default.randomUUID();
                        this.logger.trace({
                            message: `Using a fresh socket ${socketId}, setting up a new 'free' listener`,
                        });
                        this.knownSockets.set(socket, {
                            id: socketId,
                            idle_timeout_handle: undefined,
                        });
                        // When the request is complete and the socket is released,
                        // make sure that the socket is removed after `idleSocketTTL`.
                        socket.on('free', () => {
                            this.logger.trace({
                                message: `Socket ${socketId} was released`,
                            });
                            // Avoiding the built-in socket.timeout() method usage here,
                            // as we don't want to clash with the actual request timeout.
                            const idleTimeoutHandle = setTimeout(() => {
                                this.logger.trace({
                                    message: `Removing socket ${socketId} after ${this.idleSocketTTL} ms of idle`,
                                });
                                this.knownSockets.delete(socket);
                                socket.destroy();
                            }, this.idleSocketTTL).unref();
                            this.knownSockets.set(socket, {
                                id: socketId,
                                idle_timeout_handle: idleTimeoutHandle,
                            });
                        });
                        const cleanup = () => {
                            const maybeSocketInfo = this.knownSockets.get(socket);
                            // clean up a possibly dangling idle timeout handle (preventing leaks)
                            if (maybeSocketInfo?.idle_timeout_handle) {
                                clearTimeout(maybeSocketInfo.idle_timeout_handle);
                            }
                            this.logger.trace({
                                message: `Socket ${socketId} was closed or ended, 'free' listener removed`,
                            });
                        };
                        socket.once('end', cleanup);
                        socket.once('close', cleanup);
                    }
                    else {
                        clearTimeout(socketInfo.idle_timeout_handle);
                        this.logger.trace({
                            message: `Reusing socket ${socketInfo.id}`,
                        });
                        this.knownSockets.set(socket, {
                            ...socketInfo,
                            idle_timeout_handle: undefined,
                        });
                    }
                }
                // Socket is "prepared" with idle handlers, continue with our request
                pipeStream();
                // This is for request timeout only. Surprisingly, it is not always enough to set in the HTTP request.
                // The socket won't be actually destroyed, and it will be returned to the pool.
                socket.setTimeout(this.params.request_timeout, onTimeout);
            };
            function onTimeout() {
                removeRequestListeners();
                request.destroy();
                reject(new Error('Timeout error.'));
            }
            function removeRequestListeners() {
                if (request.socket !== null) {
                    request.socket.setTimeout(0); // reset previously set timeout
                    request.socket.removeListener('timeout', onTimeout);
                }
                request.removeListener('socket', onSocket);
                request.removeListener('response', onResponse);
                request.removeListener('error', onError);
                request.removeListener('close', onClose);
                if (params.abort_signal !== undefined) {
                    request.removeListener('abort', onAbort);
                }
            }
            request.on('socket', onSocket);
            request.on('response', onResponse);
            request.on('error', onError);
            request.on('close', onClose);
            if (params.abort_signal !== undefined) {
                params.abort_signal.addEventListener('abort', onAbort, { once: true });
            }
            if (!params.body)
                return request.end();
        });
    }
    async ping() {
        const abortController = new AbortController();
        try {
            const { stream } = await this.request({
                method: 'GET',
                url: (0, client_common_1.transformUrl)({ url: this.params.url, pathname: '/ping' }),
                abort_signal: abortController.signal,
            }, 'Ping');
            await (0, stream_2.drainStream)(stream);
            return { success: true };
        }
        catch (error) {
            // it is used to ensure that the outgoing request is terminated,
            // and we don't get an unhandled error propagation later
            abortController.abort('Ping failed');
            // not an error, as this might be semi-expected
            this.logger.warn({
                message: this.httpRequestErrorMessage('Ping'),
                err: error,
            });
            return {
                success: false,
                error: error, // should NOT be propagated to the user
            };
        }
    }
    async query(params) {
        const query_id = this.getQueryId(params.query_id);
        const clickhouse_settings = (0, client_common_1.withHttpSettings)(params.clickhouse_settings, this.params.compression.decompress_response);
        const searchParams = (0, client_common_1.toSearchParams)({
            database: this.params.database,
            clickhouse_settings,
            query_params: params.query_params,
            session_id: params.session_id,
            query_id,
        });
        const decompressResponse = clickhouse_settings.enable_http_compression === 1;
        const { controller, controllerCleanup } = this.getAbortController(params);
        try {
            const { stream } = await this.request({
                method: 'POST',
                url: (0, client_common_1.transformUrl)({ url: this.params.url, searchParams }),
                body: params.query,
                abort_signal: controller.signal,
                decompress_response: decompressResponse,
            }, 'Query');
            return {
                stream,
                query_id,
            };
        }
        catch (err) {
            controller.abort('Query HTTP request failed');
            this.logRequestError({
                op: 'Query',
                query_id: query_id,
                query_params: params,
                search_params: searchParams,
                err: err,
                extra_args: {
                    decompress_response: decompressResponse,
                    clickhouse_settings,
                },
            });
            throw err; // should be propagated to the user
        }
        finally {
            controllerCleanup();
        }
    }
    async exec(params) {
        const query_id = this.getQueryId(params.query_id);
        const searchParams = (0, client_common_1.toSearchParams)({
            database: this.params.database,
            clickhouse_settings: params.clickhouse_settings,
            query_params: params.query_params,
            session_id: params.session_id,
            query_id,
        });
        const { controller, controllerCleanup } = this.getAbortController(params);
        try {
            const { stream, summary } = await this.request({
                method: 'POST',
                url: (0, client_common_1.transformUrl)({ url: this.params.url, searchParams }),
                body: params.query,
                abort_signal: controller.signal,
                parse_summary: true,
            }, 'Exec');
            return {
                stream,
                query_id,
                summary,
            };
        }
        catch (err) {
            controller.abort('Exec HTTP request failed');
            this.logRequestError({
                op: 'Exec',
                query_id: query_id,
                query_params: params,
                search_params: searchParams,
                err: err,
                extra_args: {
                    clickhouse_settings: params.clickhouse_settings ?? {},
                },
            });
            throw err; // should be propagated to the user
        }
        finally {
            controllerCleanup();
        }
    }
    async insert(params) {
        const query_id = this.getQueryId(params.query_id);
        const searchParams = (0, client_common_1.toSearchParams)({
            database: this.params.database,
            clickhouse_settings: params.clickhouse_settings,
            query_params: params.query_params,
            query: params.query,
            session_id: params.session_id,
            query_id,
        });
        const { controller, controllerCleanup } = this.getAbortController(params);
        try {
            const { stream, summary } = await this.request({
                method: 'POST',
                url: (0, client_common_1.transformUrl)({ url: this.params.url, searchParams }),
                body: params.values,
                abort_signal: controller.signal,
                compress_request: this.params.compression.compress_request,
                parse_summary: true,
            }, 'Insert');
            await (0, stream_2.drainStream)(stream);
            return { query_id, summary };
        }
        catch (err) {
            controller.abort('Insert HTTP request failed');
            this.logRequestError({
                op: 'Insert',
                query_id: query_id,
                query_params: params,
                search_params: searchParams,
                err: err,
                extra_args: {
                    clickhouse_settings: params.clickhouse_settings ?? {},
                },
            });
            throw err; // should be propagated to the user
        }
        finally {
            controllerCleanup();
        }
    }
    async close() {
        if (this.agent !== undefined && this.agent.destroy !== undefined) {
            this.agent.destroy();
        }
    }
    getQueryId(query_id) {
        return query_id || crypto_1.default.randomUUID();
    }
    // a wrapper over the user's Signal to terminate the failed requests
    getAbortController(params) {
        const controller = new AbortController();
        function onAbort() {
            controller.abort();
        }
        params.abort_signal?.addEventListener('abort', onAbort);
        return {
            controller,
            controllerCleanup: () => {
                params.abort_signal?.removeEventListener('abort', onAbort);
            },
        };
    }
    logResponse(op, request, params, response, startTimestamp) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { authorization, host, ...headers } = request.getHeaders();
        const duration = Date.now() - startTimestamp;
        this.params.log_writer.debug({
            module: 'HTTP Adapter',
            message: `${op}: got a response from ClickHouse`,
            args: {
                request_method: params.method,
                request_path: params.url.pathname,
                request_params: params.url.search,
                request_headers: headers,
                response_status: response.statusCode,
                response_headers: response.headers,
                response_time_ms: duration,
            },
        });
    }
    logRequestError({ op, err, query_id, query_params, search_params, extra_args, }) {
        this.logger.error({
            message: this.httpRequestErrorMessage(op),
            err: err,
            args: {
                query: query_params.query,
                search_params: search_params?.toString() ?? '',
                with_abort_signal: query_params.abort_signal !== undefined,
                session_id: query_params.session_id,
                query_id: query_id,
                ...extra_args,
            },
        });
    }
    httpRequestErrorMessage(op) {
        return `${op}: HTTP request error.`;
    }
    parseSummary(op, response) {
        const summaryHeader = response.headers['x-clickhouse-summary'];
        if (typeof summaryHeader === 'string') {
            try {
                return JSON.parse(summaryHeader);
            }
            catch (err) {
                this.logger.error({
                    message: `${op}: failed to parse X-ClickHouse-Summary header.`,
                    args: {
                        'X-ClickHouse-Summary': summaryHeader,
                    },
                    err: err,
                });
            }
        }
    }
}
exports.NodeBaseConnection = NodeBaseConnection;
//# sourceMappingURL=node_base_connection.js.map