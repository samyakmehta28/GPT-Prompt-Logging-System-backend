/// <reference types="node" />
import type { BaseResultSet, DataFormat, ResultJSONType, ResultStream, Row } from '@clickhouse/client-common';
import type { Readable } from 'stream';
import Stream from 'stream';
/** {@link Stream.Readable} with additional types for the `on(data)` method and the async iterator.
 * Everything else is an exact copy from stream.d.ts */
export type StreamReadable<T> = Omit<Stream.Readable, 'on'> & {
    [Symbol.asyncIterator](): AsyncIterableIterator<T>;
    on(event: 'data', listener: (chunk: T) => void): Stream.Readable;
    on(event: 'close', listener: () => void): Stream.Readable;
    on(event: 'drain', listener: () => void): Stream.Readable;
    on(event: 'end', listener: () => void): Stream.Readable;
    on(event: 'error', listener: (err: Error) => void): Stream.Readable;
    on(event: 'finish', listener: () => void): Stream.Readable;
    on(event: 'pause', listener: () => void): Stream.Readable;
    on(event: 'pipe', listener: (src: Readable) => void): Stream.Readable;
    on(event: 'readable', listener: () => void): Stream.Readable;
    on(event: 'resume', listener: () => void): Stream.Readable;
    on(event: 'unpipe', listener: (src: Readable) => void): Stream.Readable;
    on(event: string | symbol, listener: (...args: any[]) => void): Stream.Readable;
};
export declare class ResultSet<Format extends DataFormat | unknown> implements BaseResultSet<Stream.Readable, Format> {
    private _stream;
    private readonly format;
    readonly query_id: string;
    constructor(_stream: Stream.Readable, format: Format, query_id: string);
    /** See {@link BaseResultSet.text}. */
    text(): Promise<string>;
    /** See {@link BaseResultSet.json}. */
    json<T>(): Promise<ResultJSONType<T, Format>>;
    /** See {@link BaseResultSet.stream}. */
    stream<T>(): ResultStream<Format, StreamReadable<Row<T, Format>[]>>;
    close(): void;
}
